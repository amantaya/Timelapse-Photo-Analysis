# Background and Configuration --------------------------------------------

## Horse-Cattle-Elk Grazing Interaction Study Rproj
## Step 4: Match Subject Photo Text Files and Copy to Subjects Sub-Folder

## What this script does:
## Reads in the subject text files from a photo collection folder
## Copies the subject photos from the text files to the "subjects" sub-folder
## Writes out a csv declaring if each photo in the collection contains a subject

## What this script requires:
## Requires CSV file from "01-extract-image-paths.R"
## This CSV file contains metadata about all photos in the collection folder
## This csv file needs to be located in the "metadata" sub-folder
## Requires subject text files generated by IrFanView
## These text files contain a file path to each photo that contains a subject
## As identified by human observers
## These text files need to be located in the "metadata" sub-folder

# Setup R Environment -----------------------------------------------------

# clear the R environment
rm(list = ls(all.names = TRUE))

# set the working directory and environment variables
source(here::here("environment.R"))

# load in the required packages
source(here::here("packages.R"))

# load in the required functions
source(here::here("functions.R"))

# Select Folders to Extract -----------------------------------------------

# create a variable to hold the file name
# in case we switch to a different project kanban board
project_kanban_file <-
  here::here(
    "docs",
    "project boards",
    "Cameratraps2 Kanban.md"
  )

# read in the kanban board for the Heber project
project_kanban <- readr::read_lines(
  here::here(
    project_kanban_file
  ),
  skip_empty_rows = FALSE,
  progress = readr::show_progress()
)

# heading patterns to find
folders_to_match_heading_regex <-
  "^##\\sFolders\\sto\\sMatch\\sSubject\\sPhotos"

folders_to_chunk_heading_regex <-
  "^##\\sFolders\\sto\\sChunk\\sSubject\\sPhotos"

# create and index of the two headings
# we want what's in between the headings
folders_to_match_heading_index <-
  stringr::str_which(project_kanban,
    pattern = folders_to_match_heading_regex
  )

folders_to_chunk_heading_index <-
  stringr::str_which(project_kanban,
    pattern = folders_to_chunk_heading_regex
  )

# add 2 because we don't want to include the first heading and the new line
# subtract 2 because we don't want to include the last heading and the new line
# subset the kanban board using these indexes
kanban_board_subset <-
  project_kanban[
    (folders_to_match_heading_index + 2):(folders_to_chunk_heading_index - 2)
  ]

cameratraps_regex_pattern <-
  "([[:upper:]][[:upper:]][[:upper:]]_\\d{8}_\\d{8}|A\\d{2}_\\d{8}_\\d{8}|[[:upper:]][[:upper:]][[:upper:]]_5min_\\d{8}_\\d{8}|[[:upper:]][[:upper:]][[:upper:]]\\d{2}_\\d{8}_\\d{8})" # nolint: line_length_linter

# extract the folders from the cameratraps project
cameratraps_folders_pattern_matches <-
  stringr::str_extract(kanban_board_subset,
                       pattern = cameratraps_regex_pattern)

# return only the pattern matches that were not NA
cameratraps_folders_pattern_matches <-
  cameratraps_folders_pattern_matches[
    is.na(cameratraps_folders_pattern_matches) == FALSE
  ]

# create a data frame with a "site" column
# that we can use to construct file paths
# TODO replace these path constructing functions with reading the file paths from a JSON
# the fromJSON creates a data frame whereas the read_json creates a list
sites_from_json <- jsonlite::fromJSON(
  here::here("data", "metadata", "cameratraps.json"))

cameratraps_folders_to_match <-
  extract_sitecode_from_collection_folder(cameratraps_folders_pattern_matches)

cameratraps_folders_to_match <-
  site_folder_from_sitecode(
    cameratraps_folders_to_match,
    path = "G:"
  )

# construct a file path to each collection folder
# by combining the site_folder and collection_folder
# for each row in the data frame
cameratraps_folders_to_match <-
  construct_path_from_collection_and_site_folders(cameratraps_folders_to_match)

# Read in Subject Text Files from Each Collection Folder ------------------

# read in the csv file that contains the metadata
# for all photos in the collection folder
all_photos_in_collection_folder <- readr::read_csv(
  here::here(
    cameratraps_folders_to_match$path[1],
    "metadata",
    paste0(cameratraps_folders_to_match$collection_folder[1], ".csv")
  )
)

# read in the text files from the metadata sub-folder
# the pattern arg should match "subjects.txt" and "no_subjects.txt" files
txt_files_from_collection_folder <-
  list.files(
    file.path(cameratraps_folders_to_match$path[1], "metadata"),
      pattern = "subjects.txt",
      full.names = TRUE
    )

# initialize an empty character vector to hold the subject photos
all_subjects_from_collection_folder <- NULL

# read the lines from each text file in the metadata folder
# appending the lines to
for (i in seq_along(txt_files_from_collection_folder)) {
all_subjects_from_collection_folder <-
  append(all_subjects_from_collection_folder,
         readr::read_lines(txt_files_from_collection_folder[i],
                           skip_empty_rows = TRUE))
}

# create a tibble to identify any missing data
# add an index to make identifying trouble data easier
all_subjects_from_collection_folder <-
  tibble::tibble("index" = seq_along(all_subjects_from_collection_folder),
                 "path" = all_subjects_from_collection_folder)

# the character strings are read into R as double-backslashes \\
# double-backslashes which are reserved characters in R
# replace these reserved characters with a single forward-slash
# R requires a single forward slash to represent file paths
all_subjects_from_collection_folder$path <-
  str_replace_all(all_subjects_from_collection_folder$path, "\\\\", "/")

# the path of each photo may be different on each computer
# so we need to make this script as flexible as possible
# to work on as many computers as possible
# we'll do this by splitting the file path string into multiple parts
# discarding the parts of the string that we don't need

all_subjects_from_collection_folder <-
  subject_text_files_to_cameratraps_path(all_subjects_from_collection_folder)

# drop rows where the file path is NA
all_subjects_from_collection_folder <-
  all_subjects_from_collection_folder %>%
  tidyr::drop_na(collection_folder) %>%
  dplyr::select(-c(index)) %>%
  tibble::rowid_to_column("index")

# Write All Subjects in Collection Folder to CSV ---------------------

# create a file name for the combined subjects csv file
all_subjects_csv_filename <-
  paste(cameratraps_folders_to_match$collection_folder[1],
    "all_subjects.csv",
    sep = "_"
  )

# write out a single csv file containing the concatenated subject text files
readr::write_csv(all_subjects_from_collection_folder,
  file = file.path(cameratraps_folders_to_match$path[1],
                   "metadata", all_subjects_csv_filename)
)

# Match Subject Photos to All Photos--------------------------------------

all_subjects_csv <- readr::read_csv(
  file.path(cameratraps_folders_to_match$path[1],
            "metadata",
            all_subjects_csv_filename))

# compare the all subjects csv to all of the photos in the collection
# to check for matching photos
# the %in% operator checks for matches from left object to the right object
# if the filename in the all_photos_in_collection_folder data frame matches
# the filename in all subjects csv file, it will report as TRUE
# only some of the values should report as TRUE (i.e. they match)
# because not all photos contain subjects

photo_contains_subject <-
  all_photos_in_collection_folder$ImageFilename %in% all_subjects_csv$filename

# create a new column in the all photos data frame
# that identifies that if the photo has a subject
# i.e. if SubjectPhoto = TRUE then that photo has been recorded
# in the subject text files as having something in it (i.e. a subject)
all_photos_in_collection_folder <-
  tibble::add_column(all_photos_in_collection_folder,
    SubjectPhoto = photo_contains_subject
  )

# filter out the images with a file size of 0 file may be corrupted
all_photos_in_collection_folder <-
  dplyr::filter(all_photos_in_collection_folder, ImageSize != 0)

# Write Matched Subject Photos to CSV --------------------------------

# create a flexible filename from the name of the collection folder
matched_subjects_csv_filename <- paste0(
  paste(cameratraps_folders_to_match$collection_folder[1],
    "matched_subject_photos",
    sep = "_"
  ),
  ".csv"
)

# write the new csv to the working directory
# we can use this new file at a later point (for machine learning)
# to identify empty photos from photos with something in them
readr::write_csv(
  all_photos_in_collection_folder,
  file = file.path(
    cameratraps_folders_to_match$path[1],
    "metadata",
    matched_subjects_csv_filename
  )
)

# Copy Subject Photos to "Subjects" Folder --------------------------------

# now that we have identified which files contain subjects
# by reading in the text files created by IrFanView
# we want to copy them to a "subjects" sub-folder in the file directory
# so we can run the Excel macro on only the photos that containing subjects
# greatly speeding up the scoring process

# define explicitly where the files are coming from
# and where we want to copy them to
# this function uses objects defined in a previous step to create file paths
# for our external hard drives
from <- file.path(all_subjects_csv$path)

to <- file.path(cameratraps_folders_to_match$path[1], "subjects")

# make a subjects folder if one doesn't already exist
# create a "metadata" directory
# if one doesn't already exist in the collection folder
if (dir.exists(
  file.path(
    cameratraps_folders_to_match$path[1],
    "subjects"
  )
) == FALSE) {
  dir.create(
    file.path(
      cameratraps_folders_to_match$path[1],
      "subjects"
    )
  )
} else {

}

# copy the photos containing subjects into the folders locations
file.copy(from = from,
          to = to,
          overwrite = FALSE)

# Check if files were not copied due to incorrect paths
# one way to do this would be to compare the number of observations
# on the all subjects data frame to the number of copied files

n_files_copied_to_subjects_folder <- list.files(file.path(
  cameratraps_folders_to_match$path[1],
  "subjects"
))

if (
  length(all_subjects_csv$path) != length(n_files_copied_to_subjects_folder)
) {
  system_time <- Sys.time()

  attr(system_time, "tzone") <- "MST"

  msg_body <-
    paste(
      "04-match-subject-photos-and-copy-to-subjects-subfolder.R",
      "ran on folder",
      cameratraps_folders_to_match$collection_folder[1],
      "n files copied does not equal n files in folder",
      system_time,
      sep = " "
    )

  RPushbullet::pbPost(type = "note", title = "WARNING", body = msg_body)
}

# Archive Completed Task on Kanban Board ----------------------------------

# create a regex to match the "Archive" heading
archive_heading_regex <- "^##\\sArchive"

# find the index of the Archive heading
archive_heading_index <-
  stringr::str_which(project_kanban,
    pattern = archive_heading_regex
  )

# create a regex to match the kanban settings section
# this is the last section on the board
kanban_settings_regex <- "^%% kanban:settings"

# find the end of the Archive heading
kanban_settings_heading_index <-
  stringr::str_which(project_kanban,
    pattern = kanban_settings_regex
  )

location_to_write_archived_task <- kanban_settings_heading_index - 2

completed_task_string <- kanban_board_subset[1]

# trim the first 6 characters from the completed task string
# i.e. remove "- [ ] "
completed_task_string_remove_checkbox <-
  stringr::str_remove(string = completed_task_string, pattern = "- \\[ \\] ")

# create an archived task string
archived_task_string <- paste("- [x]",
  Sys.time(),
  completed_task_string_remove_checkbox,
  sep = " "
)

# add the completed task to the Archive heading
project_kanban <- append(project_kanban,
  values = archived_task_string,
  after = location_to_write_archived_task
)

# Create Next Task for Kanban Board ---------------------------------------

# create a new task string to put in the next section
next_task_string <- stringr::str_replace(
  string = completed_task_string,
  pattern = "matchsubjects",
  replacement = "chunk")

# find the location of where to put the next task
folders_to_chunk_heading_index <-
  stringr::str_which(
    string = project_kanban,
    pattern = folders_to_chunk_heading_regex
  )

# create a regex to find the next heading
folders_to_copy_into_blank_macro_heading_regex <-
  "##\\sFolders\\sto\\sCopy\\sinto\\sBlank\\sMacro"

folders_to_copy_into_blank_macro_heading_index <-
  stringr::str_which(
    string = project_kanban,
    pattern = folders_to_copy_into_blank_macro_heading_regex
  )

# subtract 2 so we don't include the heading and 1 new line
location_to_put_next_task <- folders_to_copy_into_blank_macro_heading_index - 2

project_kanban <-
  append(project_kanban,
    values = next_task_string,
    after = location_to_put_next_task
  )


# Remove Completed Task from Kanban Board ---------------------------------

# find the line number of the task we completed
completed_task_index <- folders_to_match_heading_index + 2

# remove the task we completed from the kanban board
project_kanban <- project_kanban[-completed_task_index]


# Write to Kanban Board ---------------------------------------------------

readr::write_lines(project_kanban,
                   file = project_kanban_file)

# Push Notification Script Completed --------------------------------------

# get the current system time to notify when the script is completed
# note that this defaults to UTC (aka Greenwich Mean Time)
system_time <- Sys.time()

# convert into the correct timezone for your locale
# mine is Arizona so we follow Mountain Standard)
# TODO read the documenation for setting time zone
attr(system_time, "tzone") <- "MST"

msg_body <-
  paste(
    "04-match-subject-photos-and-copy-to-subjects-subfolder.R",
    "ran on folder",
    cameratraps_folders_to_match$collection_folder[1],
    "completed at",
    system_time,
    sep = " "
  )

RPushbullet::pbPost(type = "note", title = "Script Completed", body = msg_body)


# TODO once this scripts completed, move the collection folder to the next task

